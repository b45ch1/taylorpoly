\RequirePackage{ifpdf}
\ifpdf
\documentclass[a4paper,12pt,twoside]{article}
\usepackage{microtype}
\else
\documentclass[a4paper,12pt,twoside,dvips]{article}
\fi

\usepackage[scale=0.85,includeheadfoot]{geometry}
\usepackage[medium]{titlesec}

\usepackage[utf8x]{inputenc}
\usepackage[english]{babel}

\usepackage[T1]{fontenc}

\usepackage{amsmath,amsfonts,amsthm, mathtools}
% \mathtoolsset{showonlyrefs,showmanualtags}
\mathtoolsset{showmanualtags}
\usepackage{subeqnarray}
\usepackage{latexsym}

\usepackage{mathptmx}
% \usepackage{dsfont}


\usepackage{parskip}
\usepackage{fancyhdr}
\pagestyle{fancy}
%\renewcommand{\headrulewidth}{0.4pt}


\usepackage{graphicx}
\usepackage{hyperref}

\usepackage{tikz}


\graphicspath{{pics/}}

%prevent that latex tries to fill the whole page evenly with text. This looks crap since there are often huge whitespaces between paragraphs
\raggedbottom

\input{commands}

\title{Numpy Enhancement Proposal}

\author{Sebastian~F. Walter\footnote{\texttt{sebastian.walter@gmail.com}}}



\begin{document}
\maketitle

\begin{abstract}
We propose to implement vectorized algorithms for truncated univariate Taylor polynomials. They are useful for higher order algorithmic differentiation.
\end{abstract}

A truncated univariate Taylor polynomial (UTP) $[x]_D := \sum_{d=0}^{D-1} x_d t^d$ is an element of the polynomial factor ring $R[t]/t^D$. The variable $t$ is an external parameter, i.e. the polynomial $[x]_D$ is never evaluated for a numerical $t$. The UTPs are of high importance, e.g. for use in algorithmic differentiation (AD), high order polynomial models and Taylor series integrators of ODEs/DAEs.
The basic idea is that they allow to compute higher order derivatives. As a simple example we differentiate the function $f: \R^N \rightarrow R, \; x \mapsto y = f(x)$ in the so-called \emph{forward mode of AD}:
\begin{eqnarray}
\left. \frac{\dd}{\dd t} f( x + V t) \right|_{t=0} &=& \frac{\partial f}{\partial x} V \;,
\end{eqnarray}
where $V \in R^{N \times P}$. If the gradient $\nabla f(x_0)$ is desired one can set $V$ to the identity matrix $\Id_N$ and one obtains 
\begin{eqnarray}
 \left. \frac{\dd}{\dd t} f( x + V t) \right|_{t=0} &=& \frac{\partial f}{\partial x} \Id_N = \nabla f(x)\;.
\end{eqnarray}
This generalizes to higher order derivatives by computing 
\begin{eqnarray}
\left. \frac{\dd^D}{\dd t^D} f(x + Vt) \right|_{t=0} &=& \nabla^D f(x) \{ V,\dots, V \} \;.
\end{eqnarray}
The off-diagonal elements of the derivative tensor $\nabla^D f(x)$ can be computed by a technique called \emph{exact interpolation} \cite{Griewank2008EDP}.

\paragraph{Data Structure and Algorithms}
The basic data structure is the tuple $(x, V)$, where $x \in \R^N$ and $V \in R^{N \times D \times P}$ and describes a collection of univariate Taylor polynomials $[x]_{D+1}$.
To show how the algorithms have to work, we restrict to $P=1$ and look at the polynomial multiplication $z = \mul(x,y)$:
\begin{eqnarray}
[z]_{D+1} &\stackrel{D+1}{=}& [x]_{D+1} y_{D+1} \\
\sum_{d=0}^D z_d t^d &\stackrel{D+1}{=}& \left( \sum_{d=0}^D x_d t^d \right) \left( \sum_{c=0}^D y_c t^c \right)   \\
&\stackrel{D+1}{=}& \sum_{d=0}^D \sum_{k=0}^d x_k y_{d-k} t^d \\
&\stackrel{D+1}{=}& \sum_{d=0}^D \sum_{k=1}^{d-1} x_k y_{d-k} t^d  + x_0 y_d + x_d y_0\;,
\end{eqnarray}
We have used $\stackrel{D+1}{=}$ to express equality up to order $D$. That means that the algorithm for the multiplication is
{\scriptsize
\begin{verbatim}

int li(int n, int d, int p){
    /* computes linear index li = p + d*P + n*D*P */
    return p + P*(d + n*D);
}

int mul(int N, int D, int P, double x, double Vx, double y, double Vy, double z, double Vz ){
    /* computes  z = mul(x,y) */
    int n,k,d,p,tmp;
    /* compute base point */
    for(n = 0; n != N; ++n){
        z[n] = x[n]*y[n];
    }
    /* compute higher order coefficients */
    for(n = 0; n != N; ++n){
        for(d = 0; d < D; ++d){
            /* treat summation terms containing x_0 and y_0 */
            for(p = 0; p != P; ++p){
                tmp = li(n,d,p);
                Vz[tmp] = x[n] * Vy[tmp] + Vx[tmp] * y[n];
            }
            /* accumulate the remaining summation terms */ 
            for(k = 1; k < d-1; ++ k){
                for(p = 0; p != P; ++p){
                    Vz[li(n,d,p)] += Vx[li(n,k,p)] * Vy[li(n,d-k,p)]
                }
            }
        }
    }
}
\end{verbatim}
}

 

% \tableofcontents

% \input{introduction}



\bibliographystyle{plain}
\bibliography{refs}

\end{document} 
 
